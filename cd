#! /usr/bin/env bash

# $HOME is never registered
# Never use ~ when entering bookmarks in .cdmarks,
#       neither terminate paths with a /
# TODO: cd keyword1 keyword2 (for refined search)
#       Completion
cd() {
   local current="$PWD"
   local directory="${@:(-1)}"
   [[ $current == ${directory%/} ]] && return 0

   oldShoptOptions="$(shopt -p)"
   shopt -u nocasematch

   # cd, cd options only, cd /boot/grub/, cd bookmark
   if builtin cd "$@" 2>/tmp/cderror; then
      # For cd - and directory typo (ex: /var/loc Vs log) cases
      # Also cd /etc/X11/ will not create a different entry than cd /etc/X11
      directory="$PWD"
      # Update .cdmarks (weights or new entry)
      # Exclude HOME or current directory
      if [[ $directory != $HOME && $directory != $current ]]; then
         # Shrink file size to 100 lines
         if (( $(wc -l $HOME/.cdmarks | cut -d' ' -f1) > 150 )); then
            ed -s "$HOME"/.cdmarks <<< $'H\n101,$d\nwq\n'
         fi
         local line=0
         while read -r nb dir mark; do
            ((line++))
            if [[ $dir == $directory ]]; then
               local new_nb="$nb"
               local new_entry="$((++new_nb)) $dir $mark"
               # Increase weight of the directory
               # Path must not contain any @s !
               # $line s @ .* @ $new_entry @
               printf -v new_weight 'H\n%us@.*@%s@\nwq\n' "$line" "$new_entry"
               ed -s "$HOME"/.cdmarks <<< "$new_weight"
               sort -rn -o "$HOME"/.cdmarks "$HOME"/.cdmarks
               eval "$oldShoptOptions" 2>/dev/null
               return 0
            fi
         done < "$HOME"/.cdmarks
         # The directory is a new entry
         # a 1 $directory .
         printf -v new_dir 'H\na\n1 %s\n.\nwq\n' "$directory"
         ed -s "$HOME"/.cdmarks <<< "$new_dir"
         eval "$oldShoptOptions" 2>/dev/null
         return 0
      fi
   # cd wrong options
   # cd (wrong) options bookmark
   # cd               bookmark
   # Exclude cd wrong options
   elif [[ $directory != '-'* ]]; then
      # Shrink file size to 100 lines
      if (( $(wc -l $HOME/.cdmarks | cut -d' ' -f1) > 150 )); then
         ed -s "$HOME"/.cdmarks <<< $'H\n101,$d\nwq\n'
      fi
      local line=0
      while read -r nb dir mark; do
         ((line++))
         if [[ $dir == *$directory* || $mark == *$directory* ]]; then
            # cd options dir
            if builtin cd "${@:1:((${#@}-1))}" "$dir" 2>/tmp/cderror; then
               if [[ $dir != $HOME && $dir != $current ]]; then
                  local new_nb="$nb"
                  local new_entry="$((++new_nb)) $dir $mark"
                  printf -v new_weight 'H\n%us@.*@%s@\nwq\n' "$line" "$new_entry"
                  ed -s "$HOME"/.cdmarks <<< "$new_weight"
                  sort -rn -o "$HOME"/.cdmarks "$HOME"/.cdmarks
               fi
               eval "$oldShoptOptions" 2>/dev/null
               return 0
            fi
         fi
      done < "$HOME"/.cdmarks
   fi

   cat /tmp/cderror >&2; return 1
}

cds() {
   if (($#))
   then command   grep "$1" "$HOME"/.cdmarks | column -t
   else         column -t < "$HOME"/.cdmarks
   fi
}

cdc() {
   [[ -r $HOME/.cdmarks ]] && local reset='n' || local reset='y'
   read -p \
   "Are you sure you want to overwrite ~/.cdmarks with ~/.cdmarks.skel (y/N) " reset
   if [[ $reset == 'y' ]]
   then sed "s@\~@$HOME@" "$HOME"/.cdmarks.skel > "$HOME"/.cdmarks
   fi
}

cdb() {
   printf -v bookmark 'H\n/%s[^/]*$/s@\s*$@ %s@\nwq\n' "${PWD//\//\/}" "$1"
   ed -s "$HOME"/.cdmarks <<< "$bookmark"
}
