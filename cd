#! /usr/bin/env bash

shopt -u nocasematch

# $HOME is never registered
# Never use ~ when entering bookmarks in .cdmarks_after,
#       neither terminate paths with a /
# TODO: cd keyword1 keyword2 (for refined search)
#       Completion
cd() {
   # Source in order not to change this globally
   local current="$PWD"
   local directory="${@:(-1)}"
   [[ $current == $directory ]] && return 0
   local success=0
   # cd, cd options only, cd /boot/grub/, cd bookmark
   if builtin cd "$@" 2>/tmp/cderror; then
      # For cd - and directory typo (ex: /var/loc Vs log) cases
      # Also cd /etc/X11/ will not create a different entry than /etc/X11
      directory="$PWD"
      success=1
   # cd wrong options
   # cd (wrong) options bookmark
   # cd               bookmark
   # Exclude cd wrong options
   elif [[ $directory != '-'* ]]; then
      # Shrink file size to 100 lines
      if (( $(wc -l $HOME/.cdmarks_after | cut -d' ' -f1) > 100 )); then
         ed -s "$HOME"/.cdmarks_after <<< $'H\n101,$d\nwq\n'
      fi
      while read -r nb dir mark; do
         if [[ $mark == *$directory* || $dir == *$directory* ]]; then
            # cd options dir
            if builtin cd "${@:1:((${#@}-1))}" "$dir" 2>/tmp/cderror; then
               success=1
               # We need the directory corresponding to the bookmark in order to
               # update ~/.cdmarks_after
               directory="$dir"
               break
            fi
         fi
      done < <(cat "$HOME"/.cdmarks "$HOME"/.cdmarks_after 2>/dev/null)
   fi
   # Exclude HOME directory
   if ((success)) && [[ $directory != $HOME && $directory != $current ]]; then
      # Shrink file size to 100 lines
      if (( $(wc -l $HOME/.cdmarks_after | cut -d' ' -f1) > 100 )); then
         ed -s "$HOME"/.cdmarks_after <<< $'H\n101,$d\nwq\n'
      fi
      local found=0
      local line=0
      while read -r nb dir mark; do
         ((line++))
         if [[ $dir == $directory ]]; then
            found=1
            local new_nb="$nb"
            local new_entry="$((++new_nb)) $dir $mark"
            break
         fi
      done < "$HOME"/.cdmarks_after
      # Increase weight of the directory
      if ((found)); then
         # Path must not contain any @s !
         # $line s @ .* @ $new_entry @
         printf -v new_dir_weight 'H\n%us@.*@%s@\nwq\n' "$line" "$new_entry"
         ed -s "$HOME"/.cdmarks_after <<< "$new_dir_weight"
         sort -rn -o "$HOME"/.cdmarks_after "$HOME"/.cdmarks_after
      # The directory is a new entry
      else
         # a 1 $directory .
         printf -v new_dir 'H\na\n1 %s\n.\nwq\n' "$directory"
         ed -s "$HOME"/.cdmarks_after <<< "$new_dir"
      fi
   fi
   if ((success)); then
      return 0
   else
      cat /tmp/cderror >&2
      return 1
   fi
}

cds() { cat "$HOME"/.{cdmarks,cdmarks_after} 2>/dev/null | column -t; }
